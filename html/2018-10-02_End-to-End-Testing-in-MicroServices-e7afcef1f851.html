<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>End to End Testing in MicroServices</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">End to End Testing in MicroServices</h1>
</header>
<section data-field="subtitle" class="p-summary">
First things first. Testing is just a (small) part of SW Quality; It is not the whole. Everyone knows this. I know it too. I should. But…
</section>
<section data-field="body" class="e-content">
<section name="b6a6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5108" id="5108" class="graf graf--h3 graf--leading graf--title">End to End Testing in MicroServices</h3><p name="b62b" id="b62b" class="graf graf--p graf-after--h3">First things first. Testing is just a (small) part of SW Quality; It is not the whole. Everyone knows this. I know it too. I should. But then like everything, after some time, you lose the essence, the spirit; and focus on the lesser characteristics like test automation, End to End tests and so forth. For programmers and software architects/designers this is a short refresher — back to the love thy neighbor stuff.</p><p name="76c4" id="76c4" class="graf graf--p graf-after--p">Here is a picture trying to depict this.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="77fe" id="77fe" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 655px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 63.4%;"></div><img class="graf-image" data-image-id="1*ybx0malcPZOHKQeo5kR0aQ.png" data-width="4200" data-height="2664" src="https://cdn-images-1.medium.com/max/1200/1*ybx0malcPZOHKQeo5kR0aQ.png"></div><figcaption class="imageCaption">Bugs can just be tip of a Quality Iceberg</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="7a3a" id="7a3a" class="graf graf--p graf-after--figure">I tried to pack in too many metaphors in too few pixels and I agree the effect is ambiguous in parts. But overall I want to highlight the similarity between the tip of the iceberg, the visible bugs that are discovered by the customer, and the real danger that could be hiding in deep waters. Not that all bugs are like this; many are harmless floes, and many do not really wreck the customer’s deployment; only that over time the girth increases and it becomes a danger to either fast delivery of the feature or something that looks small to fix, but may need huge effort to clear. So that is the analogy of the ice-berg there explained.</p><p name="a970" id="a970" class="graf graf--p graf-after--p">What I am trying so hard to say is this, that quality is a hidden attribute, whether it is in a person, a thing or in a system. The appreciation or love to a thing/person of quality increase with time; the reverse being depreciation with time, where the object lacks thereof. A well-designed system would be something like the TCP/IP system has been extremely resilient and adapted itself from the initial time when the internet was two or three nodes and there was no World Wide Web to now; able to sustain the varied use, use cases, speed, and the devices. The Quality inherent in the system design is evident with time and usually appreciated with time. Compare this with systems, technologies, concepts, buzzwords that have come and gone and some that are with us still, but will soon be forgotten. What is good, what is not ? I remember the verse from Mark Twain recounting his time during the gold rush times in <em class="markup--em markup--p-em">Roughing It</em> .‘<a href="http://www.twainquotes.com/Gold.html" data-href="http://www.twainquotes.com/Gold.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Nothing that glitters is Gold</em></a><em class="markup--em markup--p-em">’’</em></p><h4 name="5715" id="5715" class="graf graf--h4 graf-after--p">SW Quality and Testing</h4><p name="0d5c" id="0d5c" class="graf graf--p graf-after--h4">A visible characteristic of a system is sometimes usually used intuitively to define the system; as our thoughts are not ready to admit that the characteristic could be just symptoms of something, that is not evident without real effort in understanding.</p><p name="a0e5" id="a0e5" class="graf graf--p graf-after--p">Most SW system is built after it is delivered and used. It evolves from something to something else; unless life or mission critical systems are too expensive to be exactly specified and built for a specification. Maybe the earlier systems were more in that domain and the earlier Waterfall methodology fit it more. People talk about Agile and User Story and Use Cases now, and it is as well to tell -‘“hey specifications are too hard to do for this SW that we are building for this people for this use. Let us be Agile and build this incrementally” .</p><p name="3b63" id="3b63" class="graf graf--p graf-after--p">This is perfect, I have no problem with that, I have experienced both and both are right; but this means that as the system is built and released incrementally, the end system can never be verified completely even if you put huge resources for testing, as the end system is in the domain of the future and the current test case’s can never know or verify the feature gap. What I am trying to arrive at is to tell that a system cannot be verified as it is incomplete and it is too costly to verify. To illustrate, today the system is built for a hundred users and it works fine for that much. But knowing the number of people in the planet, you can be almost sure that, if the product is successful, tomorrow it may have to serve a thousand or a million or a billion and none of these is any stretch of imagination yet. Will we test for a billion users, is it worth verifying, is it worth the waste to burn that much ‘captial runway’ especially on a new product with an uncertain future.</p><p name="b680" id="b680" class="graf graf--p graf-after--p">Here is where the un-testable part of quality comes up. This could be the reason why many say quality should be built it, and not a characteristic that can be verified and if found lacking, bolted in. If it is built in, the system would be designed to be horizontally scale-able or stateless in its load handling parts or some similar design and similar regarding security or state management or similar. None of this is verified or important in the immediate; none of this is specified, there is no accolade for doing this. Yet it is the basis for a good design.</p><p name="4744" id="4744" class="graf graf--p graf-after--p">Let us dive straight to the trade talk.</p><p name="35f9" id="35f9" class="graf graf--p graf-after--p">When you do Load Test’s, or Performance Test or Feature Test or Security test or Availability tests, you are testing some or a set of system characteristics. There is a lot of cost in doing these tests. There is a huge cost in trying to test all aspects of the system. So usually e2e tests cover only a small fragment. One that is only visible for the release. In a matrix driven world, is there a matrix other than time that can reveal or illustrate the SW Quality Aspect.</p><h4 name="e5e0" id="e5e0" class="graf graf--h4 graf-after--p">Static Code Analysis</h4><p name="1df9" id="1df9" class="graf graf--p graf-after--h4">I like the <a href="https://docs.sonarqube.org/display/SONARQUBE52/Technical+Debt" data-href="https://docs.sonarqube.org/display/SONARQUBE52/Technical+Debt" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SonarQube Technical Debt</a> visualization. It gives static code analysis results, unit test coverage (not unit test quality mind you!) and code smells — huge code blocks, too many nested loops or conditions (cyclometric complexity) and the like. What I linked in SonarQube technical debt is for an older version and the new ones has different visualizations and matrices. It is good as much as it is able to provide and we mandate its use and as a prerequisite, entry gate to another important phase-Code Review.</p><p name="80ed" id="80ed" class="graf graf--p graf-after--p">However you can have the worst quality code with hundred percent coverage, or the worst design and bad enough software implementation without anything being flagged from static code analysis. So these are minimum criteria that ensures that some level of checks are done and implementation of some minimum quality.</p><p name="89fd" id="89fd" class="graf graf--p graf-after--p">Quite often these tools under report the problems or are not configured correctly. Make sure to test these tools first and periodically.</p><p name="57d0" id="57d0" class="graf graf--p graf-after--p">Also since these tools make it visual and apparent to all regarding some aspects of Technical Debt, there is usually a very strong tendency to believe that solving this characteristic would be just enough. I would not want to repeat the diagram, but this is again just a fraction of the quality.</p><p name="7460" id="7460" class="graf graf--p graf-after--p">The ultimate tool is a skilled human mind.</p><h4 name="840b" id="840b" class="graf graf--h4 graf-after--p">Code Review</h4><p name="8802" id="8802" class="graf graf--p graf-after--h4">There are very few companies or projects which do not have this in their software implementation flow currently. But the question is that it takes time and effort and skill. The only way to have this process get better and not just kept as a namesake is for management to show interest and incentivize those who do it well, or the teams where it is practiced well.</p><h4 name="3a53" id="3a53" class="graf graf--h4 graf-after--p">Test Driven Development</h4><p name="47a7" id="47a7" class="graf graf--p graf-after--h4">There are other practices than helps in bettering the implementation and design quality; Test Driven Development being the main. Again people who are fixated by terms like TDD or Agile or Waterfall, without being able to understand the context in which it is relevant or the context which makes it relevant, can miss the picture and rant against or for it. But if we believe that modern systems are built incrementally, and you take it a level down, then you start to implement the test and the code incrementally so that the test-ability of the code and eventually the design improves when you think of how you can best frame the design for ease of test’s. Rather than bolt on test cases once the implementation is done and is fluid no more to change, either due to deadline pressures or wariness or too much time has passed and you do not remember the nitty gritty, and you do not trust enough the test cases added to cover the quality gate. These aspects are only known to the builder and the architect and this is where a good work culture or having some principles help in the final software product. As it is better to fail externally,but honorably, than to succeed externally but with a huge debt of hidden quality; and usually that debt will come calling to collect, faster than one thinks.</p><p name="014d" id="014d" class="graf graf--p graf-after--p">On a side note, as I hear it often more; TDD ? does it mean that you write the test first and then code? It makes me sick when people stick to definitions instead of understanding the spirit. Maybe we can call it just as <em class="markup--em markup--p-em">Test During Development</em> and do it what way you want as <em class="markup--em markup--p-em">Test First</em> is good way to formulate design,trying to implement some algorithms and <em class="markup--em markup--p-em">Test During</em> may suffice for routine task, as long as the code is fluid and fresh in your mind and not set yet as in set cement…</p><h4 name="536c" id="536c" class="graf graf--h4 graf-after--p">Unit Test, Integration Test and End to End Test</h4><p name="4333" id="4333" class="graf graf--p graf-after--h4">Here is where things get interesting. I guess no one now questions Unit Test. We come to Integration test and things become ambiguous immediately. As real Integration Test of the system is the End to End test ; but what is meant by me and many , is either a set of tests executed in the<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> unit test framework,</em></strong> which covers not just a function as is done by Unit tests, but a set of functions and also the first level interface partners of the component under test. I like the GRPC framework for giving unambiguous typed interface which defines and specifies the different Microservices so that it is easy to test with, by creating easy simulators that gives more quality than blind mocks in testing. These all are Integration tests. Similarly most system like Cassandra or similar can be started as a Docker container by either pre build script or part of unit test itself , to run in a minimum configuration and help in the integration tests.</p><h4 name="aa8a" id="aa8a" class="graf graf--h4 graf-after--p">Effective End-to-End Test of Micro/Services</h4><p name="ae2e" id="ae2e" class="graf graf--p graf-after--h4">This bring us to the End to End tests. I will not write here much, as much has been already written. If you have not seen this triangle, now you have, and you will start seeing this everywhere.</p><figure name="45a7" id="45a7" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 381px; max-height: 329px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 86.4%;"></div><img class="graf-image" data-image-id="0*-mkoynou6aU7OOTX.png" data-width="381" data-height="329" src="https://cdn-images-1.medium.com/max/800/0*-mkoynou6aU7OOTX.png"></div><figcaption class="imageCaption">source — <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" data-href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html</a></figcaption></figure><p name="0136" id="0136" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Here is a simplified version of the </em><a href="https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98" data-href="https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">testing pyramid</em></a><em class="markup--em markup--p-em"> from the opening keynote of the </em><a href="https://developers.google.com/google-test-automation-conference/2014/" data-href="https://developers.google.com/google-test-automation-conference/2014/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">2014 Google Test Automation Conference</em></a><em class="markup--em markup--p-em">:</em></p><p name="1bc0" id="1bc0" class="graf graf--p graf-after--p">And here is from the blog from Alister Scott. You can find reference in <a href="https://martinfowler.com/bliki/TestPyramid.html" data-href="https://martinfowler.com/bliki/TestPyramid.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">various blogs</a>.</p><figure name="0296" id="0296" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 502px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 71.6%;"></div><img class="graf-image" data-image-id="0*1hU2hqlzTyCOcb-I.jpg" data-width="1171" data-height="839" src="https://cdn-images-1.medium.com/max/800/0*1hU2hqlzTyCOcb-I.jpg"></div><figcaption class="imageCaption">source — <a href="https://watirmelon.blog/testing-pyramids/" data-href="https://watirmelon.blog/testing-pyramids/" class="markup--anchor markup--figure-anchor" rel="noopener noreferrer noopener noopener" target="_blank">https://watirmelon.blog/testing-pyramids/</a></figcaption></figure><p name="b1db" id="b1db" class="graf graf--p graf-after--figure">And this ice-cream cone or the inverse triangle is not what should be done.</p><figure name="8165" id="8165" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 864px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 123.4%;"></div><img class="graf-image" data-image-id="0*HOCE2INXBAsAQ5HU.jpg" data-width="979" data-height="1208" src="https://cdn-images-1.medium.com/max/800/0*HOCE2INXBAsAQ5HU.jpg"></div><figcaption class="imageCaption">source source — <a href="https://watirmelon.blog/testing-pyramids/" data-href="https://watirmelon.blog/testing-pyramids/" class="markup--anchor markup--figure-anchor" rel="noopener noreferrer noopener noopener noopener" target="_blank">https://watirmelon.blog/testing-pyramids/</a></figcaption></figure><p name="c1d2" id="c1d2" class="graf graf--p graf-after--figure">An anecdote first; I am bit old in the system and gone through so many process frameworks and so on and still in the game. So at one point in history there was this thing called Test Automation that gaining popularity and I was like, is this not what XP was propounding — <em class="markup--em markup--p-em">Test Driven Development. </em>No it was not exactly that, but it was that most applications for enterprise systems were moving to the web and it was a term used to test the GUI. What a terrible idea. I checked the ROBOT and other archaic Keyword driven testing frameworks and told myself that test code is code and should feel like code, not a bunch of inflexible keyword scripts; and same for Selenium, but at that time Selenium 2 or Selenium based on WebDriver was released and getting popular and you could write your browser manipulating/checking test code in Java and could even test JavaScript via that. We followed all the <a href="http://alexpunnen.blogspot.com/2017/01/best-practises-selenium-webdriver-java.html" data-href="http://alexpunnen.blogspot.com/2017/01/best-practises-selenium-webdriver-java.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">best practices</a> , and for sure it was much stable relatively than other GUI based test cases; but after about six months it became clear that to make all the test case stable was an uphill task. I realized somewhere during the time that testing a constantly evolving product, especially GUI driven testing was never going to be stable.Fast forward a couple of years and I was in a new product. Here I was adamant that there will be no automated end to end GUI tests, as I was sure that if it was said to be none, we will be able to contain with just a few over time. And mostly by this time, it was clear to all regarding the instability and futility of focusing only on GUI tests for full e2e test cases.</p><p name="a548" id="a548" class="graf graf--p graf-after--p">Instead, there was a simple Go language based or rather Go Unit Test framework based unit tests written to test all the GRPC based Micro-services; only this Go component was packaged as a testing microservice deployed as part of CD into the system where all other Docker containers were installed by CD scripts and the entry point of this Testing microservice was a ‘go test’ trigger- basically invoking the go test framework, collecting the result as a Xunit compatible file and hosting it in a simple webserver so that is can be retrieved as part of CI/CD scripts and integrated to XUnit view of Jenkins. All neat and well and simple.</p><p name="6547" id="6547" class="graf graf--p graf-after--p">Plus to cover the GUI related stuff without the GUI, the REST proxy for the GUI front-end; that is the REST interface of our BFF (Backend for Front End) component was used to drive these test cases.That is the GUI flows including login are tested based on the back-end REST proxy system that is forwarding the calls to individual microservice.</p><p name="a43a" id="a43a" class="graf graf--p graf-after--p">If you need a solution, this is a solution. But is it the full solution ? Whenever you think of this, think of the triangle. Its base is wide and the base is the unit and integration tests, the tip should be just the end to end test’s. Why ?</p><h4 name="e5b4" id="e5b4" class="graf graf--h4 graf-after--p">Problem Minor with E2E Test- Cost (Money, Time, Resource)</h4><p name="db15" id="db15" class="graf graf--p graf--startsWithDoubleQuote graf-after--h4"><em class="markup--em markup--p-em">“ End-To-End Testing is an uncomprehensive, high cost testing strategy. An end-to-end test will not check behaviours, will take time to execute, and will intermittently fail, so a test suite largely composed of end-to-end tests will result in poor test coverage, slow execution times, and non-deterministic results. Defects will go undetected, feedback will be slow and unreliable, maintenance costs will escalate, and as a result testers will be forced to rely on their own manual end-to-end regression tests. End-To-End Testing cannot produce short lead times, and it is utterly incompatible with Continuous Delivery.”</em></p><div name="6bf8" id="6bf8" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.continuousdeliveryconsulting.com/blog/end-to-end-testing-considered-harmful/" data-href="https://www.continuousdeliveryconsulting.com/blog/end-to-end-testing-considered-harmful/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.continuousdeliveryconsulting.com/blog/end-to-end-testing-considered-harmful/"><strong class="markup--strong markup--mixtapeEmbed-strong">End-To-End Testing Considered Harmful</strong><br><em class="markup--em markup--mixtapeEmbed-em">End-To-End Testing is used by many organisations, but relying on extensive end-to-end tests is fundamentally…</em>www.continuousdeliveryconsulting.com</a><a href="https://www.continuousdeliveryconsulting.com/blog/end-to-end-testing-considered-harmful/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2776dc4d19d1d25f4c622d32cab39d84" data-thumbnail-img-id="0*Mq32-OChSbsN1vB9" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Mq32-OChSbsN1vB9);"></a></div><h4 name="9546" id="9546" class="graf graf--h4 graf-after--mixtapeEmbed">Problem Major with E2E Test — Falkinees</h4><p name="6080" id="6080" class="graf graf--p graf-after--h4">Here is an excerpt from Google testing blog about flakiness; If they, with their world’s best programmers,cannot reduce, I have a feeling that it will be very hard for the rest of us; or that it is not dependent on people, but more that the act itself is futile due to the complexity.</p><p name="8981" id="8981" class="graf graf--p graf-after--p">Let me just quote as it be better to hear from the giants</p><p name="285f" id="285f" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><em class="markup--em markup--p-em">“Unfortunately, across our entire corpus of tests, we see a continual rate of about 1.5% of all test runs reporting a “flaky” result. We define a “flaky” test result as a test that exhibits both a passing and a failing result with the same code. There are many </em><a href="http://www.cs.umd.edu/~atif/pubs/gao-icse15.pdf" data-href="http://www.cs.umd.edu/~atif/pubs/gao-icse15.pdf" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank"><em class="markup--em markup--p-em">root causes</em></a><em class="markup--em markup--p-em"> why tests return flaky results, including concurrency, relying on non-deterministic or undefined behaviors, flaky third party code, infrastructure problems, etc. We have invested a lot of effort in removing flakiness from tests, but overall the insertion rate is about the same as the fix rate, meaning we are stuck with a certain rate of tests that provide value, but occasionally produce a flaky result. Almost 16% of our tests have some level of flakiness associated with them! This is a staggering numbe</em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">r; it means that more than 1 in 7 of the tests written by our world-class engineers occasionally fail in a way not caused by changes to the code or tests.”</em></strong></p><div name="0eb6" id="0eb6" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" data-href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Flaky Tests at Google and How We Mitigate Them</strong><br><em class="markup--em markup--mixtapeEmbed-em">by John Micco At Google, we run a very large corpus of tests continuously to validate our code submissions. Everyone…</em>testing.googleblog.com</a><a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b71c49708487f4f3968614e2249b7feb" data-thumbnail-img-id="0*BoyqMHxp1wA59CF2" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*BoyqMHxp1wA59CF2);"></a></div><p name="fc29" id="fc29" class="graf graf--p graf-after--mixtapeEmbed">Still not convinced- they have published a paper regarding this or rather many I guess</p><p name="f3e2" id="f3e2" class="graf graf--p graf-after--p">Here is one <em class="markup--em markup--p-em">The State of Continuous Integration Testing-</em><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45880.pdf" data-href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45880.pdf" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45880.pdf</a></p><p name="cd09" id="cd09" class="graf graf--p graf-after--p">Here are some excerpts (please do skip through if you have time)</p><blockquote name="f7d6" id="f7d6" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Flaky Tests</em></blockquote><blockquote name="9c99" id="9c99" class="graf graf--blockquote graf-after--blockquote">● Test Flakiness is a huge problem ● Flakiness is a test that is observed to both Pass and Fail with the same code ● Almost 16% of our 4.2M tests have some level of flakiness ● Flaky failures frequently block and delay releases ● Developers ignore flaky tests when submitting — sometimes incorrectly ● We spend between 2 and 16% of our compute resources re-running flaky tests</blockquote><p name="01f7" id="01f7" class="graf graf--p graf-after--blockquote">And yes they have GUI tests , but no —</p><blockquote name="407c" id="407c" class="graf graf--blockquote graf-after--p">It’s not only GUI tests. There’re many sources of flakiness, some of which Qingzhou Luo, Farah Hariri, Lamyaa Eloussi, and I analyzed in this paper: <a href="http://mir.cs.illinois.edu/marinov/publications/LuoETAL14FlakyTestsAnalysis.pdf" data-href="http://mir.cs.illinois.edu/marinov/publications/LuoETAL14FlakyTestsAnalysis.pdf" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">http://mir.cs.illinois.edu/marinov/publications/LuoETAL14FlakyTestsAnalysis.pdf</a> — <a href="https://www.blogger.com/profile/16811887500872173123" data-href="https://www.blogger.com/profile/16811887500872173123" class="markup--anchor markup--blockquote-anchor" rel="nofollow noopener" target="_blank">Darko Marinov</a> <a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html?showComment=1464739689681#c2790042815032417141" data-href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html?showComment=1464739689681#c2790042815032417141" class="markup--anchor markup--blockquote-anchor" rel="nofollow noopener" target="_blank">May 31, 2016 at 5:08:00 PM PDT</a></blockquote><p name="848c" id="848c" class="graf graf--p graf-after--blockquote">The above is again from <a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" data-href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"><em class="markup--em markup--p-em">https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html</em></a><em class="markup--em markup--p-em"> </em>and I rest my case for now;</p><p name="5980" id="5980" class="graf graf--p graf-after--p graf--trailing">Before we go there is a third factor -Problem Major Major with E2E Tests — Who writes your E2E test; Is it the developer concerned mostly of this component; or a far off independent test team who is far removed from all feature discussions and implementation weakness, or the feature test lead ? A million dollar question, but I will place my bets on the Microservice component architect that takes the role of the Feature owner.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alexcpn" class="p-author h-card">Alex Punnen</a> on <a href="https://medium.com/p/e7afcef1f851"><time class="dt-published" datetime="2018-10-02T14:46:42.438Z">October 2, 2018</time></a>.</p><p><a href="https://medium.com/@alexcpn/sw-quality-and-testing-in-microservices-e7afcef1f851" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 22, 2019.</p></footer></article></body></html>