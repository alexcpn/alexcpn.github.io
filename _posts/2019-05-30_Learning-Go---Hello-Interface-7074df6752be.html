<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Learning Go — Hello Interface</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Learning Go — Hello Interface</h1>
</header>
<section data-field="subtitle" class="p-summary">
By a Developer who does not know Go for other Developers
</section>
<section data-field="body" class="e-content">
<section name="62c3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9d68" id="9d68" class="graf graf--h3 graf--leading graf--title">Learning Go — Hello Interface</h3><h4 name="cdf1" id="cdf1" class="graf graf--h4 graf-after--h3 graf--subtitle">By a Developer who does not know Go for other Developers</h4><p name="8644" id="8644" class="graf graf--p graf-after--h4">This is part 2 of the Learning Go Series</p><p name="046b" id="046b" class="graf graf--p graf-after--p">Part 1 <a href="https://medium.com/techlogs/learning-go-hello-world-fde2e29c5eb1" data-href="https://medium.com/techlogs/learning-go-hello-world-fde2e29c5eb1" class="markup--anchor markup--p-anchor" target="_blank">https://medium.com/techlogs/learning-go-hello-world-fde2e29c5eb1</a></p><h4 name="af30" id="af30" class="graf graf--h4 graf-after--p">EPISODE 2: WHAT’S WITH INTERFACES.</h4><p name="c14a" id="c14a" class="graf graf--p graf-after--h4">What is the big deal with Interfaces? If you are a Python developer you may wonder. If you are a new programmer you may wonder more. Not that it is not there in Python ( abc from 2.7), but <a href="https://stackoverflow.com/a/19328146/429476" data-href="https://stackoverflow.com/a/19328146/429476" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">rarely</a> used compared to C++ (Abstract Class) or Java (Interfaces ). ( I use/used python a lot and strangely have not used ABC’s), though I will kick myself if I don’t use this in other languages. Maybe it depends on the nature of the SW created with Python or the dynamic nature of Python.</p><p name="28f5" id="28f5" class="graf graf--p graf-after--p">Anyway, let us stick with Go, and Interfaces are a big deal in Go.</p><h4 name="0f64" id="0f64" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Why does Go have no Inheritance- Implementation Inheritance</strong></h4><p name="d1b9" id="d1b9" class="graf graf--p graf-after--h4">Actually, it is the only deal if you are thinking of the Animal — Dog — Cat — Man speak (bark/meow/ Grunt) Object Oriented example that you have been taught in school.</p><p name="a727" id="a727" class="graf graf--p graf-after--p">While in Java you may use like</p><pre name="6518" id="6518" class="graf graf--pre graf-after--p">abstarct class Animal {</pre><pre name="7fd3" id="7fd3" class="graf graf--pre graf-after--pre">       astract public void speak();</pre><pre name="08f4" id="08f4" class="graf graf--pre graf-after--pre">}<br>class Dog extends Animal {<br> @overrrides<br>public void speak(){<br>   System.out.println(&quot;bark bark&quot;);</pre><pre name="7a01" id="7a01" class="graf graf--pre graf-after--pre">}<br>class Cat extends Animal {<br> @overrrides<br>public void speak(){<br>   System.out.println(&quot;meow meow&quot;);</pre><pre name="3743" id="3743" class="graf graf--pre graf-after--pre">}</pre><p name="5d66" id="5d66" class="graf graf--p graf-after--pre">This is fine for this example. However, very few SW projects model these kinds of textbook scenarios, and when people take concepts out of textbooks and apply it to the real world SW projects, that is when they get scared and new posts appear on the internet at regular intervals till the horror is well known.</p><p name="f612" id="f612" class="graf graf--p graf-after--p">That Extends is Evil — <a href="https://www.javaworld.com/article/2073649/why-extends-is-evil.html" data-href="https://www.javaworld.com/article/2073649/why-extends-is-evil.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://www.javaworld.com/article/2073649/why-extends-is-evil.html</a></p><p name="8af2" id="8af2" class="graf graf--p graf-after--p">Or the Fragile Base Class problem: <a href="https://en.wikipedia.org/wiki/Fragile_base_class" data-href="https://en.wikipedia.org/wiki/Fragile_base_class" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">“</em></a><em class="markup--em markup--p-em">The </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">fragile base class problem</em></strong><em class="markup--em markup--p-em"> is a fundamental architectural problem of </em><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" data-href="https://en.wikipedia.org/wiki/Object-oriented_programming" class="markup--anchor markup--p-anchor" title="Object-oriented programming" rel="noopener" target="_blank"><em class="markup--em markup--p-em">object-oriented programming</em></a><em class="markup--em markup--p-em"> systems where base classes (</em><a href="https://en.wikipedia.org/wiki/Superclass_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Superclass_(computer_science)" class="markup--anchor markup--p-anchor" title="Superclass (computer science)" rel="noopener" target="_blank"><em class="markup--em markup--p-em">superclasses</em></a><em class="markup--em markup--p-em">) are considered “fragile” because seemingly safe modifications to a base class, when inherited by the </em><a href="https://en.wikipedia.org/wiki/Subclass_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Subclass_(computer_science)" class="markup--anchor markup--p-anchor" title="Subclass (computer science)" rel="noopener" target="_blank"><em class="markup--em markup--p-em">derived classes</em></a><em class="markup--em markup--p-em">, may cause the derived classes to malfunction. The programmer cannot determine whether a base class change is safe simply by examining in isolation the methods of the base class.” </em><a href="https://en.wikipedia.org/wiki/Fragile_base_class" data-href="https://en.wikipedia.org/wiki/Fragile_base_class" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://en.wikipedia.org/wiki/Fragile_base_class</a></p><p name="22d6" id="22d6" class="graf graf--p graf-after--p">Or even the Java expert Joshua Bloch in his wildly famous <em class="markup--em markup--p-em">Effective Java bok </em>tells one not to use it/or use it very carefully — “Design and document for inheritance <strong class="markup--strong markup--p-strong">or else prohibit it</strong>”. (many links also <a href="https://stackoverflow.com/questions/218744/good-reasons-to-prohibit-inheritance-in-java" data-href="https://stackoverflow.com/questions/218744/good-reasons-to-prohibit-inheritance-in-java" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SO</a> )</p><p name="7be1" id="7be1" class="graf graf--p graf-after--p">I could go on and on, but enough said. Or here is one more from the creator of the Java Language</p><blockquote name="3f05" id="3f05" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">Bill Venners:</em></strong><em class="markup--em markup--blockquote-em"> When asked what you might do differently if you could recreate Java, you’ve said you’ve wondered what it would be like to have a language that just does delegation.</em></blockquote><blockquote name="4c21" id="4c21" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">James Gosling:</em></strong><em class="markup--em markup--blockquote-em"> Yes.</em></blockquote><blockquote name="f7d1" id="f7d1" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">Bill Venners:</em></strong><em class="markup--em markup--blockquote-em"> And we think you mean maybe throwing out class inheritance, just having interface inheritance and composition. Is that what you mean?</em></blockquote><blockquote name="400f" id="400f" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">James Gosling:</em></strong><em class="markup--em markup--blockquote-em"> In some sense I don’t know what I mean because if I knew what I meant, I would do it. There are various places where people have completed delegation-like things. Plenty of books talk about style and say delegation can be a much healthier way to do things. But specific mechanisms for how you would implement that tend to be problematic. Maybe if I was in the right mood, I’d blow away a year and just try to figure out the answer.</em></blockquote><blockquote name="d72a" id="d72a" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">Bill Venners:</em></strong><em class="markup--em markup--blockquote-em"> But by delegation, you do mean this object delegating to that object without it being a subclass?</em></blockquote><blockquote name="ab06" id="ab06" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">James Gosling:</em></strong><em class="markup--em markup--blockquote-em"> Yes — without an inheritance hierarchy. Rather than subclassing, just use pure interfaces. It’s not so much that class inheritance is particularly bad. It just has problems.</em></blockquote><blockquote name="53a3" id="53a3" class="graf graf--blockquote graf-after--blockquote"><a href="https://www.artima.com/intv/gosling3P.html" data-href="https://www.artima.com/intv/gosling3P.html" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">https://www.artima.com/intv/gosling3P.html</em></a></blockquote><p name="ecfb" id="ecfb" class="graf graf--p graf-after--blockquote">The Go designers ( Robert Grismer, Rob Pike, and none other than Ken Thompson -creator of B language -the predecessor to C language) knew well of these and Go has no support for implementation inheritance (extends in Java) and interface inheritance.</p><blockquote name="f8d7" id="f8d7" class="graf graf--blockquote graf-after--p">Go takes an unusual approach to object-oriented programming, allowing methods on any type, not just classes, <strong class="markup--strong markup--blockquote-strong">but without any form of type-based inheritance like subclassing.</strong> This means there is<strong class="markup--strong markup--blockquote-strong"> no type hierarchy</strong>. This was an intentional design choice. Although type hierarchies have been used to build much successful software,<strong class="markup--strong markup--blockquote-strong"> it is our opinion that the model has been overused and that it is worth taking a step back — </strong><a href="https://talks.golang.org/2012/splash.article" data-href="https://talks.golang.org/2012/splash.article" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">https://talks.golang.org/2012/splash.article</a></blockquote><p name="1065" id="1065" class="graf graf--p graf-after--blockquote">Nuff said about something that is not there in Go in the first place to worry about — don’t you think.</p><p name="6147" id="6147" class="graf graf--p graf-after--p">But that liberation, that freedom for those who have felt the mad subclassing orgy about a decade back will like this choice.</p><figure name="10c3" id="10c3" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 630px; max-height: 593px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 94.1%;"></div><img class="graf-image" data-image-id="1*ozN0XkzIUNO-0USjGT9h4w.png" data-width="630" data-height="593" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*ozN0XkzIUNO-0USjGT9h4w.png"></div><figcaption class="imageCaption">this is no joke — this picture is a representation of a real piece of code (obfuscated). You needed to dream within dreams to understand what was happening.</figcaption></figure><h4 name="339b" id="339b" class="graf graf--h4 graf-after--figure">Why are Interfaces so Important</h4><p name="58a7" id="58a7" class="graf graf--p graf-after--h4">The reason is Interfaces are a big deal in creating a well-designed software. The vast majority of programmers are actually Procedural Programmers. They do not understand what SW Design is and why Design is needed. Somehow this is hard to explain as it is not easy to design, but the skill of a good programmer is trying to extract the patterns in the code structure and model the code structure to align with the Open Closed Principle.</p><p name="80bd" id="80bd" class="graf graf--p graf-after--p">If you are a programmer and the above paragraph goes over your head, please stop and research this more and think. This is the only way to be a better programmer and create brittle monoliths.</p><p name="f038" id="f038" class="graf graf--p graf-after--p">Let’s pause a bit and see why Interfaces are so important even internally and why it is so less used.</p><p name="f658" id="f658" class="graf graf--p graf-after--p">Interfaces are the tool that helps you create decoupled code — Code that can be extended with time and features, code that needs less modification after it has been released. It is hard to explain with a Toy Example, as the worst examples to give are misleading examples and Object Oriented Programming textbooks are full of it. So let’s skip Animal -Cat and Dog and take a harmless example -Let us create a Command Pattern and try to illustrate how it has to be used. Read more about it here — <a href="https://en.wikipedia.org/wiki/Command_pattern" data-href="https://en.wikipedia.org/wiki/Command_pattern" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://en.wikipedia.org/wiki/Command_pattern</a></p><blockquote name="99c0" id="99c0" class="graf graf--blockquote graf-after--p">Here is a good link to get you up to speed with the syntax of interfaces — <a href="http://www.golangprograms.com/go-language/interface.html" data-href="http://www.golangprograms.com/go-language/interface.html" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">http://www.golangprograms.com/go-language/interface.html</a></blockquote><p name="27cd" id="27cd" class="graf graf--p graf-after--blockquote">Let us create a folder <em class="markup--em markup--p-em">internal_interface</em> (since we want to play with packages a bit ) and create<em class="markup--em markup--p-em"> interface.go</em></p><pre name="19a6" id="19a6" class="graf graf--pre graf-after--p">package  internal_interface</pre><pre name="cef9" id="cef9" class="graf graf--pre graf-after--pre">type CommandInterface interface {<br> Execute () int<br>}</pre><p name="fd5e" id="fd5e" class="graf graf--p graf-after--pre">Pretty simple right.Let us see how to implement concrete types of these in Go</p><p name="4369" id="4369" class="graf graf--p graf-after--p">Let us try to use this package in another package so that we are also more familiar. You can read more about packages here — <a href="https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc" data-href="https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc" class="markup--anchor markup--p-anchor" target="_blank">https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc</a></p><p name="64cc" id="64cc" class="graf graf--p graf-after--p">Let us create a folder called <em class="markup--em markup--p-em">command_pattern </em>and in it create a file <em class="markup--em markup--p-em">command_pattern.go</em></p><p name="e2b3" id="e2b3" class="graf graf--p graf-after--p">We create three types SkipCommand, JumpCommand and a FakeCommand</p><pre name="8c02" id="8c02" class="graf graf--pre graf-after--p">type SkipCommand struct {<br> //Go exports a variable if a variable name starts with Uppercase.<br>}</pre><pre name="9204" id="9204" class="graf graf--pre graf-after--pre">func (cmd SkipCommand) Execute() int {<br> fmt.Println(&quot;SKIP Command Executed&quot;)<br> return 0<br>}</pre><pre name="ce8b" id="ce8b" class="graf graf--pre graf-after--pre">type JumpCommand struct {<br>}</pre><pre name="bc5e" id="bc5e" class="graf graf--pre graf-after--pre">func (cmd JumpCommand) Execute() int {<br> fmt.Println(&quot;JUMP Command Executed&quot;)<br> return 0<br>}</pre><pre name="1c84" id="1c84" class="graf graf--pre graf-after--pre">type FakeCommand struct {<br>}</pre><p name="0735" id="0735" class="graf graf--p graf-after--pre">Note that the Execute method in the interface is implemented by SkipCommand and JumpCommand and not by FakeCommand. Go compiler automatically now infers that SkipCommand and JumpCommand implements the CommandInterface as all methods of <em class="markup--em markup--p-em">CommandInterace</em> is implemented by both.</p><p name="9798" id="9798" class="graf graf--p graf-after--p">Let’s test it out. Let us create another folder /package called <em class="markup--em markup--p-em">pattern_examples </em>and add a file <em class="markup--em markup--p-em">main.go</em> (note the package main declaration — Go compiler uses this to create an entry point for the application)</p><pre name="3ed0" id="3ed0" class="graf graf--pre graf-after--p">package main<br>import (<br> &quot;fmt&quot;</pre><pre name="7415" id="7415" class="graf graf--pre graf-after--pre">)<br>import(<br>  &quot;command_pattern&quot;<br>  &quot;internal_interface&quot;<br>)</pre><p name="ca35" id="ca35" class="graf graf--p graf-after--pre">Now before we add the main loop, lets add the million dollar function</p><pre name="0375" id="0375" class="graf graf--pre graf-after--p">// A great rule of thumb for Go is accept interfaces, return structs</pre><pre name="30e8" id="30e8" class="graf graf--pre graf-after--pre">func run(cmd internal_interface.CommandInterface)() {</pre><pre name="00ec" id="00ec" class="graf graf--pre graf-after--pre">       cmd.Execute()</pre><pre name="1ea3" id="1ea3" class="graf graf--pre graf-after--pre">}</pre><p name="790e" id="790e" class="graf graf--p graf-after--pre">If you were frustrated where the CommandInterface type that you actually defined in <em class="markup--em markup--p-em">internal_interface </em>folder is used it is used here.</p><p name="495b" id="495b" class="graf graf--p graf-after--p">If your business logic can work with Interfaces and not actual types, then you are on the path of OCP.</p><p name="0deb" id="0deb" class="graf graf--p graf-after--p">Let is finish the rest of the code</p><pre name="d894" id="d894" class="graf graf--pre graf-after--p">func main() {</pre><pre name="4707" id="4707" class="graf graf--pre graf-after--pre">skip := command_pattern.SkipCommand{}<br>jump := command_pattern.JumpCommand{}<br> <br> run(skip)<br> run(jump)</pre><pre name="80df" id="80df" class="graf graf--pre graf-after--pre">}</pre><p name="e462" id="e462" class="graf graf--p graf-after--pre">Compile and run this. You will see the statement SKIP and RUN printed. We have used a dummy interface properly. We can keep on extending different types of Commands and assuming our business logic is just selecting and executing a particular command based on a particular event, then all is well and none of the old has to change to accommodate the new.</p><pre name="bdc3" id="bdc3" class="graf graf--pre graf-after--p">go_learn# go install pattern_examples<br>go_learn# ./bin/pattern_examples <br>SKIP Command Executed<br>JUMP Command Executed</pre><p name="10ed" id="10ed" class="graf graf--p graf-after--pre">Now let’s do one more test; Let’s really check if Go compiler can catch our FakeCommand</p><pre name="7684" id="7684" class="graf graf--pre graf-after--p">func main() {</pre><pre name="4409" id="4409" class="graf graf--pre graf-after--pre">fake := command_pattern.FakeCommand{}<br> <br> run(fake)<br>}</pre><p name="7392" id="7392" class="graf graf--p graf-after--pre">Compile this and you get the error; Go is a statically typed language and this ensures that the type correctness is checked at compile time. This is pretty good as it the first test of program correctness done automatically by the compiler and one reason why it is used in commercial SW development.</p><pre name="2aeb" id="2aeb" class="graf graf--pre graf-after--p">go install pattern_examples<br># pattern_examples<br>src/pattern_examples/main.go:32:5:<strong class="markup--strong markup--pre-strong"> cannot use fake </strong>(type command_pattern<strong class="markup--strong markup--pre-strong">.FakeCommand) as type </strong>internal_interface.<strong class="markup--strong markup--pre-strong">CommandInterface in argument to run:</strong><br> command_pattern.<strong class="markup--strong markup--pre-strong">FakeCommand does not implement</strong> internal_interface.CommandInterface (missing <strong class="markup--strong markup--pre-strong">Execute method</strong>)</pre><p name="248e" id="248e" class="graf graf--p graf-after--pre">That’s all for this Episode.</p><p name="5d47" id="5d47" class="graf graf--p graf-after--p">More extra reading here</p><p name="8507" id="8507" class="graf graf--p graf-after--p">Robert C Martin — Open Closed Principle via Interface Inheritance (Abstract base classes) l<a href="https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view" data-href="https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ink</a> + History how Martin redefined the tern <a href="https://stackify.com/solid-design-open-closed-principle/" data-href="https://stackify.com/solid-design-open-closed-principle/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://stackify.com/solid-design-open-closed-principle/</a></p><p name="01ef" id="01ef" class="graf graf--p graf-after--p"><a href="https://www.calhoun.io/how-do-interfaces-work-in-go/" data-href="https://www.calhoun.io/how-do-interfaces-work-in-go/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">https://www.calhoun.io/how-do-interfaces-work-in-go/</a></p><div name="781f" id="781f" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.integralist.co.uk/posts/go-interfaces/" data-href="https://www.integralist.co.uk/posts/go-interfaces/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.integralist.co.uk/posts/go-interfaces/"><strong class="markup--strong markup--mixtapeEmbed-strong">Thinking about Interfaces in Go ⋆ Mark McDonnell</strong><br><em class="markup--em markup--mixtapeEmbed-em">Interfaces in Go Name Your Interface Arguments Keep Interfaces Small Accept Interfaces, Return Concrete Types Don&#39;t…</em>www.integralist.co.uk</a><a href="https://www.integralist.co.uk/posts/go-interfaces/" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="aa1402d811c2b0e8708a1b7807950619"></a></div><div name="1155" id="1155" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://hackernoon.com/why-i-like-gos-interfaces-2891adf2803c" data-href="https://hackernoon.com/why-i-like-gos-interfaces-2891adf2803c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/why-i-like-gos-interfaces-2891adf2803c"><strong class="markup--strong markup--mixtapeEmbed-strong">Why I like Go’s interfaces</strong><br><em class="markup--em markup--mixtapeEmbed-em">Go’s interfaces are implemented implicitly and combines the convenience of duck typing with static safety</em>hackernoon.com</a><a href="https://hackernoon.com/why-i-like-gos-interfaces-2891adf2803c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="cea7a3b464e43e7bb08582d834ff3084" data-thumbnail-img-id="0*JezwqwxeF0p38IFk." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*JezwqwxeF0p38IFk.);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alexcpn" class="p-author h-card">Alex Punnen</a> on <a href="https://medium.com/p/7074df6752be"><time class="dt-published" datetime="2019-05-30T10:38:59.937Z">May 30, 2019</time></a>.</p><p><a href="https://medium.com/@alexcpn/learning-go-hello-interface-7074df6752be" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 22, 2019.</p></footer></article></body></html>