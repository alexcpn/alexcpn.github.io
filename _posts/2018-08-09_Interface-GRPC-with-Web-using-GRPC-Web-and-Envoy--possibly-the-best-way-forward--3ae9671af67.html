<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Interface GRPC with Web using GRPC-Web and Envoy (possibly the best way forward)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Interface GRPC with Web using GRPC-Web and Envoy (possibly the best way forward)</h1>
</header>
<section data-field="subtitle" class="p-summary">
The path forward to access a GRPC server directly via browser seems to be Google’s grpc-web project; though it uses Envoy Proxy internally.
</section>
<section data-field="body" class="e-content">
<section name="46bb" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6ee3" id="6ee3" class="graf graf--h3 graf--leading graf--title">Interface GRPC with Web using GRPC-Web and Envoy (possibly the best way forward)</h3><p name="1d4b" id="1d4b" class="graf graf--p graf-after--h3">The path forward to access a GRPC server directly via browser seems to be Google’s <a href="https://github.com/grpc/grpc-web/" data-href="https://github.com/grpc/grpc-web/" class="markup--anchor markup--p-anchor" rel="noopener nofollow noopener" target="_blank">grpc-web</a> project; though it uses Envoy Proxy internally.</p><p name="b8a3" id="b8a3" class="graf graf--p graf-after--p">Note that there is one <a href="https://medium.com/techlogs/grpc-web-interface-a95f0d3e5467" data-href="https://medium.com/techlogs/grpc-web-interface-a95f0d3e5467" class="markup--anchor markup--p-anchor" target="_blank">more older way</a> and that is also called grpc-web (<a href="https://github.com/improbable-eng/grpc-web" data-href="https://github.com/improbable-eng/grpc-web" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener noopener" target="_blank">https://github.com/improbable-eng/grpc-web</a>). But this one is from GRPC /Google itself — <a href="https://github.com/grpc/grpc-web" data-href="https://github.com/grpc/grpc-web" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener noopener" target="_blank">https://github.com/grpc/grpc-web</a>.This is pretty exciting! From their site</p><p name="dda5" id="dda5" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><em class="markup--em markup--p-em">“gRPC-Web provides a Javascript client library that lets browser clients access a gRPC server ..The JS client library has been used for some time by Google and Alphabet projects with the </em><a href="https://github.com/google/closure-compiler" data-href="https://github.com/google/closure-compiler" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"><em class="markup--em markup--p-em">Closure compiler</em></a><em class="markup--em markup--p-em"> and its TypeScript generator (which has not yet been open-sourced).</em></p><p name="eff8" id="eff8" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">gRPC-Web clients connect to gRPC servers via a special gateway proxy: our provided version uses </em><a href="https://www.envoyproxy.io/" data-href="https://www.envoyproxy.io/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"><em class="markup--em markup--p-em">Envoy</em></a><em class="markup--em markup--p-em">, in which gRPC-Web support is built-in. Envoy will become the default gateway for gRPC-Web by GA.</em></p><p name="b8c8" id="b8c8" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">The current release is a Beta release, and we expect to announce General-Available by Oct. 2018.”</em></p><p name="0f5f" id="0f5f" class="graf graf--p graf-after--p">GRPC is clearly a neat technology when it comes to MS. <a href="https://hackernoon.com/rest-in-peace-grpc-for-micro-service-and-grpc-for-the-web-a-how-to-908cc05e1083" data-href="https://hackernoon.com/rest-in-peace-grpc-for-micro-service-and-grpc-for-the-web-a-how-to-908cc05e1083" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">Typed versioned interfaces is one hidden requirement if you want to get Micro Services or SOA right</a>. One question that comes always or what developers (including me) miss is the accessibility of the GRPC API when compared with REST API. It is not so hard to fire up a simple Python client or Node.JS TypeScript client to access the API’s. But if it is as accessible as REST API’s are from a browser it would be great.</p><p name="97c4" id="97c4" class="graf graf--p graf-after--p graf--trailing">The tutorial (<a href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/tutorial.md" data-href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/tutorial.md" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/tutorial.md</a>) is good enough; but I stumbled a few times. Hope this helps and is based on the above tutorial + examples and some partial work I did for proxying via Envoy.</p></div></div></section><section name="a0e8" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="faaf" id="faaf" class="graf graf--p graf--leading">Here is what we are going to do</p><figure name="7d00" id="7d00" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 343px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 49%;"></div><img class="graf-image" data-image-id="1*86eBU8TxkwYBLS_NqwzTqA.png" data-width="1040" data-height="510" src="https://cdn-images-1.medium.com/max/800/1*86eBU8TxkwYBLS_NqwzTqA.png"></div><figcaption class="imageCaption">(thanks to LucidChart drawing SW)</figcaption></figure><p name="924a" id="924a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step 1:</strong></p><p name="1e75" id="1e75" class="graf graf--p graf-after--p">First start your GRPC server (any language) at some port, say <strong class="markup--strong markup--p-strong">17007 .</strong> Here is a sample protobuffer file / proto file (I have masked out parts, you can use any proper proto file)</p><pre name="b9cf" id="b9cf" class="graf graf--pre graf-after--p">syntax = &quot;proto3&quot;;</pre><pre name="b761" id="b761" class="graf graf--pre graf-after--pre">package xxx.yyy_service;</pre><pre name="639b" id="639b" class="graf graf--pre graf-after--pre">service SomeService {<br>  <br>  rpc testMe(Parameters) returns (Response);<br>  //will work with server side streams also<br>   rpc testMeStream(Parameters) returns (stream Response);</pre><pre name="52c8" id="52c8" class="graf graf--pre graf-after--pre">}</pre><pre name="fcbd" id="fcbd" class="graf graf--pre graf-after--pre">message Response {<br>  int32 response = 1;<br>};</pre><pre name="cce1" id="cce1" class="graf graf--pre graf-after--pre">message FileDetails { <br>  string fileUrl = 1;<br>  string outputfolder = 2;<br>};</pre><pre name="e2a2" id="e2a2" class="graf graf--pre graf-after--pre">message Parameters {<br>   FileDetails file_details = 1;<br>};</pre><p name="eaa8" id="eaa8" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Step 2 Envoy Proxy Bridge</strong></p><p name="92cd" id="92cd" class="graf graf--p graf-after--p">You need to start an Envoy Proxy to bridge GRPC( HTTP/2) with Browser Communication (HTTP/1.1) . E<a href="https://www.envoyproxy.io/" data-href="https://www.envoyproxy.io/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">nvoy</a> from Lyft (ride share company) is the backbone of other Kubernetes related Service Mesh like <a href="https://istio.io/" data-href="https://istio.io/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">Istio</a>, maybe due to the fact of it’s support for GRPC from the beginning.</p><p name="5d91" id="5d91" class="graf graf--p graf-after--p">Here is a sample Envoy proxy configuration <a href="https://gist.github.com/alexcpn/e71f3e32c2928f540f5aafee36827aa4#file-envoy-yaml" data-href="https://gist.github.com/alexcpn/e71f3e32c2928f540f5aafee36827aa4#file-envoy-yaml" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"><em class="markup--em markup--p-em">envoy.yaml</em></a> and the associated <em class="markup--em markup--p-em">Dockerfile</em> to build Envoy with this configuration .</p><p name="93ea" id="93ea" class="graf graf--p graf-after--p">Two parts of this are interesting. The HTTP listener listening at <strong class="markup--strong markup--p-strong">8080 </strong>and moving traffic to echo_service -our GRPC server at local IP and <strong class="markup--strong markup--p-strong">17007</strong> port.</p><figure name="1b2a" id="1b2a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alexcpn/e71f3e32c2928f540f5aafee36827aa4#file-envoy-yaml.js"></script></figure><p name="4f0f" id="4f0f" class="graf graf--p graf-after--figure">With these two let us build an Envoy Docker image ( run the below command in same folder where you have the Dockerfile and envoy.yaml; change the ports as you wish)</p><p name="27a7" id="27a7" class="graf graf--p graf-after--p">Build envoy</p><pre name="3ee5" id="3ee5" class="graf graf--pre graf-after--p">sudo -E  docker build -t envoy:v1 .</pre><p name="2639" id="2639" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Step 3</strong>: Run Envoy proxy.</p><pre name="5775" id="5775" class="graf graf--pre graf-after--p">sudo docker run  -p 8080:8080 --net=host  envoy:v1</pre><p name="01b4" id="01b4" class="graf graf--p graf-after--pre">I am running this in the host network (-p has no meaning now) as within the Envoy image the port 17007 is inaccessible. Better would be to run your GRPC server within the Envoy Docker or vice versa; or create a NW layer (say in Kuberenetes ) where the ports are accessible.</p><p name="1018" id="1018" class="graf graf--p graf-after--p">Now we have GRPC server running in 17007 and Envoy running intercepting GRPC traffic (HTTP 2) at 8080 and directing it to 1700 as HTTP 1.1. But this conversion has to follow the GRPC framing rules. (feel free to skip to <strong class="markup--strong markup--p-strong">Step 4 </strong>as below is not interesting generally)</p><pre name="dba8" id="dba8" class="graf graf--pre graf-after--p"><a href="https://www.envoyproxy.io/docs/envoy/v1.5.0/configuration/http_filters/grpc_http1_bridge_filter#config-http-filters-grpc-bridge" data-href="https://www.envoyproxy.io/docs/envoy/v1.5.0/configuration/http_filters/grpc_http1_bridge_filter#config-http-filters-grpc-bridge" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener" target="_blank">https://www.envoyproxy.io/docs/envoy/v1.5.0/configuration/http_filters/grpc_http1_bridge_filter#config-http-filters-grpc-bridg</a>e</pre><pre name="6402" id="6402" class="graf graf--pre graf-after--pre">When a request is sent, the filter sees if the connection is HTTP/1.1 and the request content type is application/grpc.</pre><pre name="c0f1" id="c0f1" class="graf graf--pre graf-after--pre">If so, when the response is received, the filter buffers it and waits for trailers and then checks the grpc-status code. If it is not zero, the filter switches the HTTP response code to 503. It also copies the grpc-status and grpc-message trailers into the response headers so that the client can look at them if it wishes.</pre><pre name="3b26" id="3b26" class="graf graf--pre graf-after--pre">The client should send HTTP/1.1 requests that translate to the following psuedo headers:<br>:method: POST<br>:path: &lt;gRPC-METHOD-NAME&gt;<br>content-type: application/grpc</pre><pre name="f6c7" id="f6c7" class="graf graf--pre graf-after--pre">The body should be the serialized grpc body which is:<br>1 byte of zero (not compressed).<br>network order 4 bytes of proto message length.<br>serialized proto message.</pre><pre name="4515" id="4515" class="graf graf--pre graf-after--pre">Because this scheme must buffer the response to look for the grpc-status trailer it will only work with unary gRPC APIs.</pre><p name="60a2" id="60a2" class="graf graf--p graf-after--pre">Via PostMan you can try the following</p><figure name="a245" id="a245" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 427px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 61%;"></div><img class="graf-image" data-image-id="1*TTRAsKugV1oRH7Ue75oJmQ.png" data-width="1292" data-height="788" src="https://cdn-images-1.medium.com/max/800/1*TTRAsKugV1oRH7Ue75oJmQ.png"></div></figure><p name="5330" id="5330" class="graf graf--p graf-after--figure">In the GRPC server I managed to get the redirect form Envoy</p><pre name="b2b4" id="b2b4" class="graf graf--pre graf-after--p">E0724 10:01:51.297989923    1685 http_server_filter.cc:241]  GET request without QUERY<br>E0724 10:02:13.139528491    1685 b64.cc:168]                 Invalid padding detected.<br>E0724 10:02:21.578859033    1685 b64.cc:168]                 Invalid padding detected.<br>E0724 10:04:44.931591481    1685 b64.cc:168]                 Invalid padding detected.</pre><p name="dc8a" id="dc8a" class="graf graf--p graf-after--pre">This is because I have not followed the rules of padding .You can try this simple Python client to do the body padding</p><p name="4eb8" id="4eb8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 4: Generate JS Client Stubs</strong></p><p name="2571" id="2571" class="graf graf--p graf-after--p">Generate the client Stubs. For this you need just <a href="https://github.com/google/protobuf" data-href="https://github.com/google/protobuf" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"><em class="markup--em markup--p-em">protoc</em></a></p><pre name="aee2" id="aee2" class="graf graf--pre graf-after--p">protoc -I=../Interfaces/xxx/ --js_out=import_style=closure,binary:./build ../Interfaces/xxx/yyy.proto</pre><p name="352e" id="352e" class="graf graf--p graf-after--pre">This will generate a slew of .js files that has the message definitions. In our case <em class="markup--em markup--p-em">filedetails.js,parameters.js,response.js</em> . Place all of this in one folder.</p><p name="8c6c" id="8c6c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 5</strong></p><p name="0da1" id="0da1" class="graf graf--p graf-after--p">Now we need to generate the GRPC service stub.For this you need to first <em class="markup--em markup--p-em">make</em> grpc-web’s<strong class="markup--strong markup--p-strong"> <em class="markup--em markup--p-em">protoc-gen-grpc-web</em></strong> binary .</p><p name="dc7e" id="dc7e" class="graf graf--p graf-after--p">Clone <a href="https://github.com/grpc/grpc-web" data-href="https://github.com/grpc/grpc-web" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">grpc-web</a> repository</p><pre name="2710" id="2710" class="graf graf--pre graf-after--p">cd to grpc-web/javascript/net/grpc/web/<br>make<br># this will generate protoc-gen-grpc-web executable</pre><p name="4fff" id="4fff" class="graf graf--p graf-after--pre">Note the path of <em class="markup--em markup--p-em">protoc-gen-grpc-web</em> binary. Use this to generate the GRPC realted stubs</p><pre name="cbee" id="cbee" class="graf graf--pre graf-after--p">protoc -I=../Interfaces/xxx/ --plugin=protoc-gen-grpc-web=/home/alex/coding/grpc-web-google/grpc-web/javascript/net/grpc/web/<strong class="markup--strong markup--pre-strong">protoc-gen-grpc-web</strong> --grpc-web_out=out=<strong class="markup--strong markup--pre-strong">client.grpc.pb.js</strong>,mode=<a href="https://github.com/grpc/grpc-web/issues/231" data-href="https://github.com/grpc/grpc-web/issues/231" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener" target="_blank"><strong class="markup--strong markup--pre-strong">grpcwebtext</strong></a>:./build ../Interfaces/xxx/yyy.proto</pre><p name="6f99" id="6f99" class="graf graf--p graf-after--pre">Note the <em class="markup--em markup--p-em">mode name</em></p><p name="0064" id="0064" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 6. Merge all JS files together</strong></p><p name="ba0c" id="ba0c" class="graf graf--p graf-after--p">Combine all the generated <strong class="markup--strong markup--p-strong">*.js</strong> file to a single one using the Google’s<a href="https://developers.google.com/closure/compiler/docs/gettingstarted_app" data-href="https://developers.google.com/closure/compiler/docs/gettingstarted_app" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank"> closure compiler</a>. (In the tutorial another method is <a href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/tutorial.md" data-href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/tutorial.md" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">followed</a>). I got the closure method from this document — <a href="https://github.com/grpc/grpc-web/blob/master/INSTALL.md" data-href="https://github.com/grpc/grpc-web/blob/master/INSTALL.md" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/grpc/grpc-web/blob/master/INSTALL.md</a></p><pre name="05b1" id="05b1" class="graf graf--pre graf-after--p">$ wget <a href="http://dl.google.com/closure-compiler/compiler-latest.zip" data-href="http://dl.google.com/closure-compiler/compiler-latest.zip" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">http://dl.google.com/closure-compiler/compiler-latest.zip</a> -O compiler-latest.zip<br>$ unzip -p -qq -o compiler-latest.zip *.jar &gt; closure-compiler.jar</pre><p name="4c31" id="4c31" class="graf graf--p graf-after--pre">Move the .jar to the root of grpc-web project.</p><pre name="4e70" id="4e70" class="graf graf--pre graf-after--p">java -jar ./closure-compiler.jar  --js ./javascript --js ./net --js /home/alex/coding/<strong class="markup--strong markup--pre-strong">closure-library</strong>  --js /home/alex/coding/<strong class="markup--strong markup--pre-strong">protobuf</strong>/js --js /home/alex/coding/xxx/js-generated/*.js --entry_point=goog:xxx.yyy_service.SomeServiceClient --dependency_mode=STRICT --js_output_file compiled.js</pre><p name="aef7" id="aef7" class="graf graf--p graf-after--pre">Note-The sub-modules inside third-party were empty after checkout of grpc-web and I had to clone the <em class="markup--em markup--p-em">closure-library</em> and already had the protobuf library cloned for building grpc. The rest of the packages are in root of <a href="https://github.com/grpc/grpc-web" data-href="https://github.com/grpc/grpc-web" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">grpc-web</a>.</p><p name="57fb" id="57fb" class="graf graf--p graf-after--p">This will give us one compiled JavaScript file. Using this we can write a HTML file to use it.</p><p name="e191" id="e191" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 7 : Write the JS code and serve via NGINX</strong></p><p name="b0ba" id="b0ba" class="graf graf--p graf-after--p">Notice how we included the <em class="markup--em markup--p-em">compiled.js</em> file and also how the request is framed.</p><p name="4a34" id="4a34" class="graf graf--p graf-after--p">If we serve this via opening in a browser locally, you may run into CORS problem. So given is a bare-bones<em class="markup--em markup--p-em"> nginx.conf</em> to server this html</p><figure name="714f" id="714f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alexcpn/1e39dd58efbf9ced17805c2f5aa07c6a#file-index-html.js"></script></figure><p name="e826" id="e826" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step 7</strong></p><p name="fc91" id="fc91" class="graf graf--p graf-after--p">Run the nginx server with the nginx.conf file . It starts a web-server on port 5000</p><pre name="d8e6" id="d8e6" class="graf graf--pre graf-after--p">sudo docker run --rm   --net=host -v /home/alex/coding/xx/js-generated/compiled/:/usr/share/nginx/html -v /home/alex/coding/xx/js-generated/compiled/nginx.conf:/etc/nginx/nginx.conf:ro nginx</pre><p name="3563" id="3563" class="graf graf--p graf-after--pre">That’s it. Use a browser go to <a href="http://localhost:5000" data-href="http://localhost:5000" class="markup--anchor markup--p-anchor" target="_blank">http://localhost:5000</a> , I tested with Chrome, use the developer view (F12 / Cntrl-Shft-C in Chrome ) to see the console logs, as the script is executed while the page is loaded.</p><p name="8d15" id="8d15" class="graf graf--p graf-after--p">References</p><div name="bbf5" id="bbf5" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://hackernoon.com/rest-in-peace-grpc-for-micro-service-and-grpc-for-the-web-a-how-to-908cc05e1083" data-href="https://hackernoon.com/rest-in-peace-grpc-for-micro-service-and-grpc-for-the-web-a-how-to-908cc05e1083" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/rest-in-peace-grpc-for-micro-service-and-grpc-for-the-web-a-how-to-908cc05e1083" rel="nofollow"><strong class="markup--strong markup--mixtapeEmbed-strong">REST is not the Best for Micro-Services GRPC and Docker makes a compelling case</strong><br><em class="markup--em markup--mixtapeEmbed-em">For quite a long time, when Service Oriented Architecture (SOA) and WebService were the talk of the tech town, most of…</em>hackernoon.com</a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alexcpn" class="p-author h-card">Alex Punnen</a> on <a href="https://medium.com/p/3ae9671af67"><time class="dt-published" datetime="2018-08-09T08:14:53.606Z">August 9, 2018</time></a>.</p><p><a href="https://medium.com/@alexcpn/interface-grpc-with-web-using-grpc-web-and-envoy-possibly-the-best-way-forward-3ae9671af67" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 22, 2019.</p></footer></article></body></html>