<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Micro Services &amp; Git</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Micro Services &amp; Git</h1>
</header>
<section data-field="subtitle" class="p-summary">
Mono/Multi Repo, Balancing Feature Branches and Continuous Integration
</section>
<section data-field="body" class="e-content">
<section name="6e78" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ab1c" id="ab1c" class="graf graf--h3 graf--leading graf--title">Micro Services &amp; Git</h3><h4 name="38cd" id="38cd" class="graf graf--h4 graf-after--h3 graf--subtitle">Mono/Multi Repo, Balancing Feature Branches and Continuous Integration</h4><p name="67bd" id="67bd" class="graf graf--p graf-after--h4 graf--trailing">If you are confused between mono repository or multi-repository or a branch and merge strategy for micro-services - feature branches, trunk based development or release branches, then this post will have something for you. There is no one right way, but as with life, to choose a better way ,you need to be first self aware. Similarly to choose a source control strategy for your project, you need to be aware of the analysis process, development process, balance of parallel feature development with CI and CD,code review and merge process and component ownership patterns in your teams.</p></div></div></section><section name="900c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="48d4" id="48d4" class="graf graf--p graf--leading">Git is by default the version control system used by most modern software projects. I have seen that the perspective is different if you have worked in worse version control systems at first. But for the new generation of programmers Git may be the their first ‘worst’ source control system. And for those many now and many more in the future, maybe it is good to start with a little about Git first.</p><p name="b1d2" id="b1d2" class="graf graf--p graf-after--p">Most SW developers who has worked for a decade or more would be familiar with one or the other of the centralised version control systems that was prevalent at that time. I started out with building a windows client for CVS as part of industry project. After that, for quite a lot of years was using the <a href="https://news.ycombinator.com/item?id=8483045" data-href="https://news.ycombinator.com/item?id=8483045" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">monster</a> called ClearCase, and then I moved to a more modern project based on Java and Agile practices and there was introduced to Subversion/SVN and things started looking good. Everything looks good after ClearCase.</p><p name="db39" id="db39" class="graf graf--p graf-after--p">SVN looked good, and it seems there was nothing better to wish for. But then came Git and it suddenly felt empowering; that’s something strange to be said about a version control system. Git was built by a developer for the developer. Very few people would write a poem about SVN, ClearCase or the like, but Git is different.</p><p name="eef1" id="eef1" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Till then I dreaded to branch fearing the cost,<br>Or more the dread to think of the merge,<br>But then came Git,<br>And lo! I am in branching heaven!`</em></p><p name="e364" id="e364" class="graf graf--p graf-after--p">There was no more need to be heavily depended on the source control operations team. Since it is a <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">distributed</em></strong><em class="markup--em markup--p-em"> version control </em>system, everyone has a copy of the repository in his laptop, that one can work <strong class="markup--strong markup--p-strong">offline</strong> with. That is incrementally commit to, branch out etc as with any SCM (source code management). Linus designed and implemented Git as a SCM replacement for Linux as the one they were using Bitkeeper became licensed. The key here is <strong class="markup--strong markup--p-strong">distributed</strong> version control system. Linus Torvalds presentation regarding the rationale of why he developed Git , in his inimitable style is a <a href="https://www.youtube.com/watch?v=4XpnKHJAok8" data-href="https://www.youtube.com/watch?v=4XpnKHJAok8" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">must watch</a> before you do anything with Git.</p><figure name="361f" id="361f" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/4XpnKHJAok8?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe></figure><p name="351d" id="351d" class="graf graf--p graf-after--figure">So what is lost from centralised version control system; nothing much.You can always designate one repository in a server as the central repository- ‘origin’, to which all others raise a ‘merge request’ or ‘push’ their local commits.</p><p name="425b" id="425b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Branching and Merging in Git,perfectly implemented:</strong></p><p name="4ccf" id="4ccf" class="graf graf--p graf-after--p">Git which makes it very easy to branch and merge. All SCM’s support branch and merge; but the implementations <a href="https://stackoverflow.com/a/19340965/429476" data-href="https://stackoverflow.com/a/19340965/429476" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">were not as good </a>to say the least. In SVN a branch is a copy of the folder in the server and all its contents. In Git a branch is nothing but a pointer to a commit.</p><p name="d46e" id="d46e" class="graf graf--p graf-after--p">This ability to easily branch and merge means that there quite a lot of ways to structure the flow of code from development to release. We will come to this part in a short while. Before that, maybe it is as well to dwell a little on some characteristics of Git that some may not realise at first.</p><p name="aeda" id="aeda" class="graf graf--p graf-after--p">Since Git is a DVCS (distributed version control system), if someone has committed a large file or set of files in a different branch,and pushed to ‘origin’ repo, it will be downloaded to everyone’s machine once they do a ‘pull’ or ‘fetch’ from ‘origin’; that is synced their repository with the designated ‘central’ repository. This is not a typical use case, but sometimes binaries or generated files gets ‘added’ and ‘pushed’ inadvertently. And even if the developer realises and immediately deletes the file, and commits and push again, the Git history has the file in its commit and history is usually kept immutable unless of course you do a ‘hard reset’ and do a forced push. This is not recommended as it may cause inconsistency if somebody already has ‘pulled’ the <em class="markup--em markup--p-em">history </em>with the commit into his or her local repository.</p><p name="7a2b" id="7a2b" class="graf graf--p graf-after--p">This means that if you are on a slow network,which strangely even now most of the enterprise IT systems are,the clone of big repository take some time to download. You can do some tricks like shallow clone etc, but Git was not meant for huge (&gt;1 GB) repositories. Of course, if you store only source code, you would no have this problem. Note you could use something like Git Large File System (<a href="https://www.atlassian.com/git/tutorials/git-lfs" data-href="https://www.atlassian.com/git/tutorials/git-lfs" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.atlassian.com/git/tutorials/git-lfs</a>) or other in your server to take care of it.</p><p name="8948" id="8948" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Tip</strong>: Want to clean your repo, use <a href="https://rtyley.github.io/bfg-repo-cleaner/" data-href="https://rtyley.github.io/bfg-repo-cleaner/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://rtyley.github.io/bfg-repo-cleaner/</a>; <a href="https://stackoverflow.com/questions/2100907/how-to-remove-delete-a-large-file-from-commit-history-in-git-repository" data-href="https://stackoverflow.com/questions/2100907/how-to-remove-delete-a-large-file-from-commit-history-in-git-repository" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://stackoverflow.com/questions/2100907/how-to-remove-delete-a-large-file-from-commit-history-in-git-repository</a></p><p name="3fd2" id="3fd2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Tip: </strong>For CI/CD or to just see the latest source, you can do a <em class="markup--em markup--p-em">shallow clone </em>of a branch and clone should finish in few seconds even if repo is large</p><pre name="0034" id="0034" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">git clone --depth 1 https://path/to/repo/repo.git -b branchname</code></pre><p name="682b" id="682b" class="graf graf--p graf-after--pre">The other problem, if you can really call it that, is that it is slightly complex to use; primarily because it is distributed in nature and primarily it was written by a developer (see the video if you have not). But in the years hence many have contributed and now it is as usable as any other tool. It may look and feel similar to SVN, but you will commit mistakes if you do not take a day or two to learn the basics. I am no expert in it, but have used it for some years now, reverted merge commits across parent branches ( bit chilly) and prayed and did hard resets of the history more than once.</p><p name="1f43" id="1f43" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Tip :</strong>I have survived all this while with a <a href="https://git-scm.com/book/en/v2/Getting-Started-Git-Basics" data-href="https://git-scm.com/book/en/v2/Getting-Started-Git-Basics" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">few git commands</a>;</p><p name="d036" id="d036" class="graf graf--p graf-after--p">git clone, git checkout (-b for new) &lt;branch-name&gt;, git branch (to see where you are), git fetch, git merge, git pull (does previous two in one go),git stash (sometimes), git reset (and its options- very very carefully), git log, <a href="https://randyfay.com/content/avoiding-git-disasters-gory-story" data-href="https://randyfay.com/content/avoiding-git-disasters-gory-story" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">git force push </a>(very few times).. and maybe some more</p><p name="ee04" id="ee04" class="graf graf--p graf-after--p">There are a ton of other commands out there; be wary, understand and use; or <strong class="markup--strong markup--p-strong">better not use</strong> if you do not understand the implications fully — example <a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1" data-href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1" class="markup--anchor markup--p-anchor" target="_blank">git rebase</a>- <a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1" data-href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1</a></p><p name="c75b" id="c75b" class="graf graf--p graf-after--p">Here are some of the StackOverFlow questions and answers that I found to be very helpful</p><pre name="f11c" id="f11c" class="graf graf--pre graf-after--p">Reverting normal commits (don&#39;t do this till really needed as history is changed!)</pre><pre name="b022" id="b022" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/22682870/git-undo-pushed-commits" data-href="https://stackoverflow.com/questions/22682870/git-undo-pushed-commits" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/22682870/git-undo-pushed-commits</a></pre><pre name="5722" id="5722" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/4114095/how-to-revert-a-git-repository-to-a-previous-commit/4114122#4114122" data-href="https://stackoverflow.com/questions/4114095/how-to-revert-a-git-repository-to-a-previous-commit/4114122#4114122" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/4114095/how-to-revert-a-git-repository-to-a-previous-commit/4114122#4114122</a></pre><pre name="b1b7" id="b1b7" class="graf graf--pre graf-after--pre">Reverting Merge commit (bit hairy,as now there are two paths )</pre><pre name="2d97" id="2d97" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/7099833/how-to-revert-a-merge-commit-thats-already-pushed-to-remote-branch" data-href="https://stackoverflow.com/questions/7099833/how-to-revert-a-merge-commit-thats-already-pushed-to-remote-branch" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/7099833/how-to-revert-a-merge-commit-thats-already-pushed-to-remote-branch</a></pre><pre name="6a4b" id="6a4b" class="graf graf--pre graf-after--pre">Resolving Merge conflict</pre><pre name="386f" id="386f" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git" data-href="https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git</a></pre><pre name="ddc0" id="ddc0" class="graf graf--pre graf-after--pre">For easy working</pre><pre name="5a22" id="5a22" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github" data-href="https://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github</a></pre><pre name="2c98" id="2c98" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/11265463/reset-git-proxy-to-default-configuration" data-href="https://stackoverflow.com/questions/11265463/reset-git-proxy-to-default-configuration" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/11265463/reset-git-proxy-to-default-configuration</a></pre><pre name="af50" id="af50" class="graf graf--pre graf-after--pre"><a href="https://stackoverflow.com/questions/594757/how-do-i-do-a-git-status-so-it-doesnt-display-untracked-files-without-using" data-href="https://stackoverflow.com/questions/594757/how-do-i-do-a-git-status-so-it-doesnt-display-untracked-files-without-using" class="markup--anchor markup--pre-anchor" rel="noopener noreferrer noopener" target="_blank">https://stackoverflow.com/questions/594757/how-do-i-do-a-git-status-so-it-doesnt-display-untracked-files-without-using</a></pre><p name="473e" id="473e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Mono Repo or Multi Repo ?</strong></p><p name="3e7a" id="3e7a" class="graf graf--p graf-after--p">There are two way’s to host a project; as a single repository -mono repository or a set of multiple repositories. Before we go any further, let us ask this question first.</p><blockquote name="c1ea" id="c1ea" class="graf graf--blockquote graf-after--p">What constitutes a micro-service project?</blockquote><p name="9f10" id="9f10" class="graf graf--p graf-after--blockquote">If we define a project as a set of micro-services that collaborate with each other using some sort of typed interfaces (like protobuffer), then there is a clear advantage in sharing interfaces unambiguously and singularly. For this there should be only one copy of the interfaces and I feel the best way to do is is using a <em class="markup--em markup--p-em">single repository /</em>mono- repository.</p><p name="b5c7" id="b5c7" class="graf graf--p graf-after--p">Is there a way to do singular versioning of Interfaces using multiple repositories ? Not in an elegant, non manual way.</p><p name="29b8" id="29b8" class="graf graf--p graf-after--p">The very nature of multiple repository means that you need to assign one repository as a truth for interfaces and have some or other non elegant work agreement to copy manually to and fro from this repository to your repository or use sub modules. Both are prone to mistakes. Managing this via reference to an external repository via sub-module,<a href="https://github.com/ingydotnet/git-subrepo#readme" data-href="https://github.com/ingydotnet/git-subrepo#readme" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> sub-tree</a> seems like a good fit, but it is an <a href="http://slopjong.de/2013/06/04/git-why-submodules-are-evil/" data-href="http://slopjong.de/2013/06/04/git-why-submodules-are-evil/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">abstraction that is quite leaky</a> and need to used very carefully.</p><p name="ea0f" id="ea0f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">The better way to share interfaces is by a shared branch, not by a shared repository; in short mono-repo is what I would recommend for micro-services.</em></strong></p><p name="a843" id="a843" class="graf graf--p graf-after--p">The caveat here is that if your project is composed of ten’s of thousands components and gigabits of source files, all sharing interfaces, Git won’t be good in handling that; and you need to break this into different repository.</p><p name="69cd" id="69cd" class="graf graf--p graf-after--p">Update July 2018: Today I read in a recent write-up on the problems another company faced with multiple repos (and micro services), and it gives me yet more confidence to recommend mono repo. Usually what trips you in the end are things that does not seem like problem in the beginning, example consistent interface versioning. I am adding a few excerpts from <a href="https://segment.com/blog/goodbye-microservices/" data-href="https://segment.com/blog/goodbye-microservices/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://segment.com/blog/goodbye-microservices/</a></p><blockquote name="6342" id="6342" class="graf graf--blockquote graf-after--p">Scaling Microservices and Repos<br>As time went on, we added over 50 new destinations, and that meant 50 new repos. To ease the burden of developing and maintaining these codebases, we created shared libraries.</blockquote><blockquote name="76a1" id="76a1" class="graf graf--blockquote graf-after--blockquote">The shared libraries made building new destinations quick. The familiarity brought by a uniform set of shared functionality made maintenance less of a headache.</blockquote><blockquote name="9d18" id="9d18" class="graf graf--blockquote graf-after--blockquote">Over time, the versions of these shared libraries began to diverge across the different destination codebases. The great benefit we once had of reduced customization between each destination codebase started to reverse.</blockquote><blockquote name="f21e" id="f21e" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Moving to a Monorepo</strong><br>(context — they migrated from micro service to a single service, so they needed just one repo, however the problem they faced with multi repo with microservices are highlighted in the blog)</blockquote><blockquote name="8363" id="8363" class="graf graf--blockquote graf-after--blockquote">..With this transition, we no longer needed to keep track of the differences between dependency versions. <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">All our destinations were using the same version</em></strong>, which significantly reduced the complexity across the codebase.</blockquote><blockquote name="042e" id="042e" class="graf graf--blockquote graf-after--blockquote graf--trailing"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">With this transition, we no longer needed to keep track of the differences between dependency versions. </em></strong>All our destinations were using the same version, which significantly reduced the complexity across the codebase</blockquote></div></div></section><section name="a72f" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0b8b" id="0b8b" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">Choose your branching strategy: <em class="markup--em markup--p-em">Feature branch vs Trunk Based development vs Release Branch</em></strong></p><p name="8ce0" id="8ce0" class="graf graf--p graf-after--p">With Git the general tendency is to increase the number of branches that is used. When we talk about branches the context here is the ‘public’ branches or the one others collaborate on.There is no problem in having thousand’s of personal branches.</p><p name="640e" id="640e" class="graf graf--p graf-after--p">Branches have usually a hidden relation with your SW release methodology, merge quality, merge process and merge frequency. This will be especially evident when you have many SW developers working for a product collaboratively in an enterprise SW product development scenario. A good branching strategy should have clear code review and merge ownership for each branch, should give freedom to work in parallel for multiple features by multiple teams and still be able to release frequently. This is a hard ask than what you may think.</p><p name="76ba" id="76ba" class="graf graf--p graf-after--p">There is not one best solution for all scenarios.</p><p name="bb20" id="bb20" class="graf graf--p graf-after--p">Continuous Delivery is one of the hardest release strategy to achieve. When you are in such a mode, the master branch, or trunk, is pretty stable to incoming merges. That is, the code that passes the merge criteria, be it code review process, or SW developer process or SW developer quality is at a pretty high standard. In this situation the strategy is predominantly trunk based development. That is feature branches are cut from the trunk, they are relatively short lived and is merged back to the trunk.</p><p name="2d2f" id="2d2f" class="graf graf--p graf-after--p">Who owns the feature branch ? Usually it will be the feature lead who will also be an expert in the domain and in programming. Or it will be collective ownership of all the component leads contributing to the branch.</p><p name="7995" id="7995" class="graf graf--p graf-after--p">The same model may not make much sense and may cause problems if every other merge is causing instability in the product created from the trunk. When this happens you have production and development moving further away from the trunk. That is cut a <em class="markup--em markup--p-em">release</em> branch once <em class="markup--em markup--p-em">master</em> is stabilised for a release and then take bug correction merges on the <em class="markup--em markup--p-em">release</em>. Meanwhile the <em class="markup--em markup--p-em">master</em> is mostly red (meaning the CI driven automated test cases is red). Feature branches are cut and most of the time is spend in working on the feature branches without daring to or able to merge to master. Typical opposite of real Continuous Integration.</p><p name="a326" id="a326" class="graf graf--p graf-after--p">Between these two strategies, that is trunk based development with short lived feature branches, or release branch based development with long feature branches, there are a gazillion strategies you can choose or build, and whatever you choose, make sure to refine and adapt it over time as your team evolves into you release evolves towards CD.</p><p name="c537" id="c537" class="graf graf--p graf-after--p">Here is one such for every need and every hour <a href="https://www.atlassian.com/agile/software-development/branching" data-href="https://www.atlassian.com/agile/software-development/branching" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.atlassian.com/agile/software-development/branching</a> . Or the much more famous one here (Git flow) with a develop branch for CI and a master branch for release — <a href="https://nvie.com/posts/a-successful-git-branching-model/" data-href="https://nvie.com/posts/a-successful-git-branching-model/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p name="87a2" id="87a2" class="graf graf--p graf-after--p">Is there any special branching strategy needed for Micro Services ?</p><p name="c0b3" id="c0b3" class="graf graf--p graf-after--p">Here is one I used. There is a special branch called ‘<em class="markup--em markup--p-em">interfaces</em>’ cut from master. This is done at the start. For each MS there is a folder created with the MS name, but which contains only the interface/GRPC proto file for the MS in ‘<em class="markup--em markup--p-em">interfaces</em>’ branch.For each MS there is a ‘<em class="markup--em markup--p-em">MS main</em>’ branch that is cut from <em class="markup--em markup--p-em">interfaces, </em>which contains a folder for the MS and implementation. This is merged to <em class="markup--em markup--p-em">master </em>branch periodically. The <em class="markup--em markup--p-em">interfaces </em>branch is merged into <em class="markup--em markup--p-em">MS main </em>frequently. The master is never merged to <em class="markup--em markup--p-em">MS-main</em> but the flow is from MS-main to master. <em class="markup--em markup--p-em">Interfaces </em>will have just interfaces for all MS. Development happens on branches cut from the <em class="markup--em markup--p-em">MS main</em> and merged back. The <em class="markup--em markup--p-em">MS-main </em>is merged to master. Each MS sees only the interfaces of other MS and its own folder/implementation.</p><p name="daee" id="daee" class="graf graf--p graf-after--p">A typical feature is implemented across multiple MS in feature branches that are merged into <em class="markup--em markup--p-em">MS main</em> by MS component lead. The advantage of this is that each MS can work on the feature in a isolated way. This reduces merge conflict and ownership ambiguity. The ownership to review and merge to <em class="markup--em markup--p-em">MS main </em>lies with the MS component lead. There is also a Jenkins pipeline configured for CI for each MS. Other than reduction in possible merge conflicts and non-ambiguity of branch ownership, this particular strategy has not much benefits.</p><p name="545f" id="545f" class="graf graf--p graf-after--p">We can also have the feature branch concept here. That is latest of each MS will be a folder in <em class="markup--em markup--p-em">master </em>branch, and latest of each released MS will be a folder in <em class="markup--em markup--p-em">release </em>branch. For a feature, a branch is cut from <em class="markup--em markup--p-em">master</em> and all component owners branch off this branch and raise merge request to this branch. There are two activities the feature branch owner (feature owner) has to do. Since there would be parallel development and merges to master, the master has to be merged periodically to the feature branch and merge conflicts if any resolved. Also the feature branch has to be reviewed and merged to master. There are quite a lot of redundancies here.</p><p name="7cfd" id="7cfd" class="graf graf--p graf-after--p">The same concept can be simplified by cutting feature branch by each MS and then raising merge to master, which the MS component owner will merge. The problem is that the system composed of the builds from latest master will have unfinished features in. Some of these could be DB table updates or GUI changes. It is not a good idea to release half baked features. The problem is that some other smaller feature may be already completed and merged to master, and the bigger unfinished features for the same component that is present in master makes things like <a href="https://martinfowler.com/articles/feature-toggles.html" data-href="https://martinfowler.com/articles/feature-toggles.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">feature toggle</em></strong></a><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">s</em></strong> and related overhead necessary.</p><p name="df15" id="df15" class="graf graf--p graf-after--p">Is there a way out between choosing between Continuous Integration and parallel feature development ?</p><p name="54a2" id="54a2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Feature branch and one-way continuous integration</strong></p><p name="f4e3" id="f4e3" class="graf graf--p graf-after--p">What if instead of merging to master frequently, master is merged to the feature branch frequently. This will mean still that the feature is still not continuously integrated to master till it is fully Done. But since master is merged to feature branches the merge and functionality conflicts in the final merge of the feature branch to the master may be reduced. This may be a better way than <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">feature toggles</em></strong>.</p><figure name="4824" id="4824" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 541px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 77.3%;"></div><img class="graf-image" data-image-id="1*9cSnqslLV76gOoxaFhW6Qg.png" data-width="1774" data-height="1371" src="https://cdn-images-1.medium.com/max/800/1*9cSnqslLV76gOoxaFhW6Qg.png"></div></figure><p name="6361" id="6361" class="graf graf--p graf-after--figure graf--trailing">What should be realized is that there are more important things than branching strategy that has to be correct for CI and CD to work. This could start as early as requirement analysis and splitting features to smaller User Stories that can be released independently and integrated more frequently to trunk.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alexcpn" class="p-author h-card">Alex Punnen</a> on <a href="https://medium.com/p/d840305e6220"><time class="dt-published" datetime="2018-06-20T06:13:26.459Z">June 20, 2018</time></a>.</p><p><a href="https://medium.com/@alexcpn/micro-services-git-d840305e6220" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 22, 2019.</p></footer></article></body></html>